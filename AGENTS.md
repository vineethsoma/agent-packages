# AGENTS.md
<!-- Generated by APM CLI from distributed .apm/ primitives -->
<!-- Build ID: __BUILD_ID__ -->
<!-- APM Version: 0.7.0 -->
<!-- Source: local -->

## Files matching `**`

<!-- Source: local agents/feature-lead/apm_modules/vineethsoma/agent-packages/skills/spec-driven-development/.apm/instructions/spec-first.instructions.md -->
# Spec-First Development Instructions

## Core Rule: No Implementation Without Specification

**MANDATORY**: Before writing any code, create or update the specification.

### When to Create Specs

- ‚úÖ **New features**: Always start with `/speckit.specify`
- ‚úÖ **Bug fixes affecting behavior**: Document expected vs actual in spec
- ‚úÖ **Architecture changes**: Update constitution first
- ‚úÖ **API changes**: Update contracts in `specs/{feature}/contracts/`
- ‚ùå **Trivial refactors**: No spec needed for code style/formatting only

### Spec Lifecycle

```
1. Constitution     ‚Üí Define principles (once per project)
2. Feature Spec     ‚Üí What to build and why
3. Plan             ‚Üí Technical approach and structure
4. Tasks            ‚Üí Breakdown into user stories
5. Implementation   ‚Üí Build according to spec
6. Validation       ‚Üí Verify against acceptance criteria
```

### Validation Checklist

Before marking any task complete:
- [ ] Spec exists in `specs/{feature-id}/spec.md`
- [ ] Acceptance criteria clearly defined
- [ ] Implementation matches spec requirements
- [ ] All spec clarifications addressed
- [ ] Constitution principles upheld

### Spec File Structure

```
specs/
‚îî‚îÄ‚îÄ {feature-id}/
    ‚îú‚îÄ‚îÄ spec.md              # Main specification
    ‚îú‚îÄ‚îÄ plan.md              # Implementation plan
    ‚îú‚îÄ‚îÄ tasks.md             # Task breakdown
    ‚îú‚îÄ‚îÄ contracts/           # API contracts
    ‚îÇ   ‚îî‚îÄ‚îÄ api.openapi.yml
    ‚îî‚îÄ‚îÄ checklists/          # Quality gates
        ‚îî‚îÄ‚îÄ requirements.md
```

## Spec Commands Reference

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `/speckit.constitution` | Define project principles | Start of project |
| `/speckit.specify` | Create feature spec | New feature request |
| `/speckit.clarify` | Add clarifications to spec | Ambiguous requirements |
| `/speckit.plan` | Generate implementation plan | After spec approval |
| `/speckit.tasks` | Break down into stories | Ready to implement |

## Common Anti-Patterns

‚ùå **Writing code first, spec later**: Leads to post-hoc documentation
‚ùå **Skipping clarifications**: Results in implementation drift
‚ùå **Generic acceptance criteria**: Makes validation impossible
‚ùå **No constitution review**: Violates project principles

## Integration with TDD

Spec-driven and test-driven development work together:

1. **Spec defines WHAT** (functional requirements, acceptance criteria)
2. **Tests define HOW WELL** (quality, edge cases, performance)
3. **Implementation satisfies BOTH**

Write tests based on spec acceptance criteria, then implement to pass tests.

<!-- Source: local skills/refactoring-patterns/.apm/instructions/refactoring-discipline.instructions.md -->
# Refactoring Discipline

Apply incremental refactoring with test-driven discipline: Small Change ‚Üí Test ‚Üí Commit ‚Üí Repeat.

## Core Principle

**Preserve behavior while improving structure**

Refactoring is NOT:
- ‚ùå Adding new features
- ‚ùå Fixing bugs
- ‚ùå Changing behavior

Refactoring IS:
- ‚úÖ Improving code organization
- ‚úÖ Clarifying intent
- ‚úÖ Reducing complexity
- ‚úÖ Making code easier to understand and modify

## The Refactoring Cycle

```
1. Identify small change (< 10 lines)
2. Make the change
3. Run ALL tests (must pass)
4. Commit
5. Repeat
```

**NEVER make multiple refactorings without testing between each one**

## Refactoring Safety Rules

**Rule 1: Tests Must Exist**
- No refactoring without test coverage
- If no tests exist, write characterization tests first
- Tests document current behavior (even if buggy)

**Rule 2: One Change at a Time**
- Extract ONE method
- Rename ONE variable
- Eliminate ONE duplication
- Not all three at once

**Rule 3: Test After Every Change**
- Run full test suite
- All tests must pass
- No "I'll test after I'm done"

**Rule 4: Commit Frequently**
- Commit after each successful refactor
- Small commits = easy to revert
- Commit message: "Refactor: [what you did]"

**Rule 5: If Tests Fail, Revert**
- Don't debug refactoring failures
- Revert to last green state
- Try smaller change

## Common Refactoring Patterns

### Extract Method
**When**: Function is too long or has complex logic

**Before**:
```python
def process_order(order):
    # Validate order
    if not order.items:
        raise ValueError("Order has no items")
    if order.total < 0:
        raise ValueError("Invalid total")
    
    # Calculate discount
    discount = 0
    if order.customer.is_premium:
        discount = order.total * 0.1
    
    # Apply payment
    final_total = order.total - discount
    order.customer.charge(final_total)
```

**After**:
```python
def process_order(order):
    validate_order(order)
    discount = calculate_discount(order)
    charge_customer(order, discount)

def validate_order(order):
    if not order.items:
        raise ValueError("Order has no items")
    if order.total < 0:
        raise ValueError("Invalid total")

def calculate_discount(order):
    if order.customer.is_premium:
        return order.total * 0.1
    return 0

def charge_customer(order, discount):
    final_total = order.total - discount
    order.customer.charge(final_total)
```

**Steps**:
1. Extract `validate_order()` ‚Üí Test ‚Üí Commit
2. Extract `calculate_discount()` ‚Üí Test ‚Üí Commit
3. Extract `charge_customer()` ‚Üí Test ‚Üí Commit

### Rename Variable/Function
**When**: Name doesn't clearly express intent

**Before**:
```python
def calc(x, y):
    return x * y * 0.2
```

**After**:
```python
def calculate_sales_tax(subtotal, tax_rate):
    return subtotal * tax_rate * 0.2
```

### Introduce Explaining Variable
**When**: Complex expression is hard to understand

**Before**:
```python
if (user.age >= 18 and user.country == "US") or user.has_parental_consent:
    allow_registration()
```

**After**:
```python
is_adult_in_us = user.age >= 18 and user.country == "US"
can_register = is_adult_in_us or user.has_parental_consent

if can_register:
    allow_registration()
```

### Replace Magic Number with Constant
**When**: Unexplained literal values

**Before**:
```python
def calculate_shipping(weight):
    if weight < 5:
        return 4.99
    return 9.99
```

**After**:
```python
LIGHTWEIGHT_THRESHOLD_LBS = 5
LIGHTWEIGHT_SHIPPING_COST = 4.99
STANDARD_SHIPPING_COST = 9.99

def calculate_shipping(weight):
    if weight < LIGHTWEIGHT_THRESHOLD_LBS:
        return LIGHTWEIGHT_SHIPPING_COST
    return STANDARD_SHIPPING_COST
```

### Consolidate Duplicate Code
**When**: Same logic appears in multiple places

**Before**:
```python
def format_user_email(user):
    return f"{user.first_name} {user.last_name} <{user.email}>"

def format_admin_email(admin):
    return f"{admin.first_name} {admin.last_name} <{admin.email}>"
```

**After**:
```python
def format_email_address(person):
    return f"{person.first_name} {person.last_name} <{person.email}>"
```

### Simplify Conditional
**When**: Complex nested conditionals

**Before**:
```python
def can_approve_expense(user, amount):
    if user.role == "manager":
        if amount < 1000:
            return True
        else:
            if user.department == "executive":
                return True
    return False
```

**After**:
```python
def can_approve_expense(user, amount):
    if user.role != "manager":
        return False
    
    if amount < 1000:
        return True
    
    return user.department == "executive"
```

### Replace Conditional with Polymorphism
**When**: Type checking with if/switch statements

**Before**:
```python
def calculate_pay(employee):
    if employee.type == "salaried":
        return employee.monthly_salary
    elif employee.type == "hourly":
        return employee.hours * employee.rate
    elif employee.type == "commissioned":
        return employee.base_salary + employee.commission
```

**After**:
```python
class SalariedEmployee:
    def calculate_pay(self):
        return self.monthly_salary

class HourlyEmployee:
    def calculate_pay(self):
        return self.hours * self.rate

class CommissionedEmployee:
    def calculate_pay(self):
        return self.base_salary + self.commission
```

## Refactoring Red Flags

**üö´ Large Multi-Step Refactoring**
- If you can't commit within 15 minutes, change is too big
- Break into smaller steps

**üö´ Tests Failing Mid-Refactor**
- Revert immediately
- Don't try to "fix it"
- Try smaller change

**üö´ Mixing Refactoring with Features**
- Separate commits: refactor OR feature, not both
- Refactor first, then add feature with tests

**üö´ Refactoring Without Tests**
- STOP
- Write characterization tests first
- Then refactor with safety

## When to Refactor

**Before adding a feature**:
- Makes space for new feature
- "Make the change easy, then make the easy change" - Kent Beck

**During code review**:
- Improve clarity for reviewers
- Extract complex logic
- Improve naming

**When you notice duplication** (Rule of Three):
- First time: write code
- Second time: note duplication
- Third time: refactor to remove duplication

**When you notice code smells**:
- Long methods (> 20 lines)
- Complex conditionals (> 3 nested levels)
- Duplicated code
- Large classes (> 500 lines)
- Long parameter lists (> 4 parameters)

## When NOT to Refactor

**On buggy code**:
- Fix bug first with tests
- Then refactor

**Near a deadline**:
- Refactoring can wait
- Don't risk breaking working code

**On code you don't understand**:
- Study code first
- Write tests to understand behavior
- Then refactor

**On third-party code**:
- Can't control upstream changes
- Wrap and adapt instead

---

**Remember**: Small Change ‚Üí Test ‚Üí Commit. Never compromise on testing between refactorings.

<!-- Source: local skills/task-delegation/.apm/instructions/delegation-protocol.instructions.md -->
# Task Delegation Standards

Delegate user stories to specialized agents with complete context and clear ownership.

## Delegation Principles

### 1. Complete Context Transfer

Every delegation includes:
- **User story specification**: What to build
- **Acceptance criteria**: Definition of done
- **Dependencies**: What must be ready first
- **Handoff requirements**: What next story needs
- **Branch/worktree assignment**: Where to work
- **Constitution/spec references**: Project standards

### 2. Clear Ownership

- One agent per story (no shared ownership)
- Agent owns story from start to merge
- Agent responsible for tests and documentation
- Agent reports completion status

### 3. Skill Matching

Match story requirements to agent expertise:
- Frontend work ‚Üí Agent with frontend skills
- Backend API ‚Üí Agent with backend + database skills
- Full-stack ‚Üí Agent with both frontend and backend
- Infrastructure ‚Üí Agent with DevOps skills

## Delegation Template

```markdown
## Story Delegation: US-[Number]

**Assigned To**: [Agent Name/Role]
**Story Title**: [User story title]
**Priority**: [High | Medium | Low]
**Estimated Effort**: [Hours or points]

### Context
[Brief description of what this story achieves within the feature]

### Acceptance Criteria
- [ ] [Specific, testable criterion 1]
- [ ] [Specific, testable criterion 2]
- [ ] [Specific, testable criterion 3]

### Dependencies
**Requires** (must be complete first):
- US-[X]: [What it provides]

**Blocks** (waiting on this story):
- US-[Y]: [What it needs from this]

### Technical Details
**Branch**: `feat-us[number]`
**Worktree**: `worktrees/feat-us[number]/`
**Files to modify**: [List of main files]
**New files to create**: [List if known]

### Handoff to Next Story
[What the next story needs from this one:
- API endpoints
- Shared types/interfaces
- Database schema
- Configuration]

### Standards
- Follow CLAUDE Framework coding standards
- Use TDD workflow (Red ‚Üí Green ‚Üí Refactor)
- Minimum 80% test coverage
- Reference constitution: [link to AGENTS.md or Constitution]

### Communication
- Report progress daily
- Flag blockers immediately
- Update status when complete
```

## Delegation Workflow

### 1. Feature Lead Prepares Delegation

```bash
# Create worktree for story
git worktree add -b feat-us1 worktrees/feat-us1 main

# Create delegation document
cat > worktrees/feat-us1/DELEGATION.md << 'EOF'
[Use template above]
EOF
```

### 2. Agent Accepts Delegation

```markdown
## Delegation Accepted: US-001

**Agent**: Fullstack Engineer Agent
**Acknowledged**: [Timestamp]
**Estimated Completion**: [Date]

### Understanding Confirmed
- [x] Read acceptance criteria
- [x] Reviewed dependencies
- [x] Understood handoff requirements
- [x] Worktree set up and tested

### Questions/Clarifications
[None | List any questions before starting]
```

### 3. Agent Works on Story

- Work in assigned worktree
- Follow TDD workflow
- Commit regularly with clear messages
- Run tests frequently

### 4. Agent Reports Completion

```markdown
## Story Complete: US-001

**Completed**: [Timestamp]
**Commits**: [abc123, def456, ...]
**Tests**: ‚úÖ All passing (Coverage: 85%)

### Acceptance Criteria
- [x] POST /api/users endpoint implemented
- [x] Email validation working
- [x] Tests pass with >80% coverage

### Handoff to US-002
- API endpoints ready: POST /api/users
- OpenAPI spec updated: contracts/api.openapi.yml
- Shared types exported: src/types/user.ts
- Integration tests pass

### Merge Request
Ready to merge `feat-us1` to `main`
- [x] All tests pass
- [x] Rebased on latest main
- [x] No merge conflicts
- [x] Documentation updated
```

### 5. Feature Lead Reviews and Merges

```bash
# Review story
cd worktrees/feat-us1
npm test  # Verify tests pass

# Merge to main
cd ../../main/
git merge feat-us1 --no-ff
git push origin main

# Cleanup
git worktree remove worktrees/feat-us1

# Update feature context
# Notify next dependent story
```

## Multi-Agent Coordination

**Parallel execution**:
```markdown
## Feature: User Management

**Active Delegations**:
- US-001: Backend API ‚Üí Agent A (Worktree: feat-us1) - Status: üîÑ WIP
- US-002: Frontend UI ‚Üí Agent B (Worktree: feat-us2) - Status: ‚è≥ Blocked (needs US-001)
- US-003: Integration ‚Üí Agent C (Worktree: feat-us3) - Status: ‚è≥ Blocked (needs US-001, US-002)

**Merge Order**:
1. US-001 (no dependencies)
2. US-002 (depends on US-001)
3. US-003 (depends on US-001, US-002)
```

## Anti-Patterns

**üö´ Unclear acceptance criteria**:
- Criteria must be specific and testable
- "Make it work" is NOT acceptance criteria
- "API returns 201 with user object" IS

**üö´ Missing dependencies**:
- Always document what must be ready first
- Don't let agents discover dependencies mid-work

**üö´ No handoff requirements**:
- Next story needs to know what's available
- Document API contracts, types, schemas

**üö´ Delegating without worktree**:
- Every story gets its own worktree
- Prevents branch switching and conflicts

---

**Remember**: Clear delegation = successful execution. Complete context prevents rework.

<!-- Source: local skills/feature-orchestration/.apm/instructions/orchestration-standards.instructions.md -->
# Feature Orchestration Standards

Coordinate multi-story features with consistency validation and progress tracking.

## Feature Context Management

**Maintain big picture across all stories**:

```markdown
## Feature Context

**Feature**: [Name from Constitution/Spec]
**Stories**: [List with status]
**Active Branches**: [Worktrees currently WIP]
**Dependencies**: [Cross-story dependencies]
**Last Sync**: [Timestamp]

### Story Handoffs
- Story A ‚Üí Story B: [Required state/contracts]
- Story B ‚Üí Story C: [Prerequisites]
```

## Cross-Story Consistency

**Validate consistency across stories**:
- Shared contracts (API schemas, types, interfaces)
- Naming conventions across frontend/backend
- Database schema alignment
- Error handling patterns

**Run consistency checks**:
```bash
# Type checking across frontend/backend
npm run type-check  # Frontend
mypy src/          # Backend

# Contract validation
npm run validate-openapi
```

## Progress Tracking

**Story Status Board**:
```markdown
| Story | Status | Assignee | Branch | Tests | Blockers |
|-------|--------|----------|--------|-------|----------|
| US-001 | ‚úÖ Done | Agent A | - | ‚úÖ Pass | - |
| US-002 | üîÑ WIP | Agent B | feat-us2 | üîÑ Running | - |
| US-003 | ‚è≥ Blocked | Agent C | - | - | Needs US-002 |
```

## Merge Coordination

**Merge order matters**:
1. Stories must merge in dependency order
2. Integration tests run after each merge
3. Feature branch stays updated with main

**Merge protocol**:
```bash
# Agent completes story
git worktree remove worktrees/feat-us1
git checkout main
git merge feat-us1 --no-ff
git push origin main

# Update feature context
# Notify next dependent story
```

## Anti-Patterns to Avoid

**üö´ Forgetting cross-story impacts**:
- Changes to shared contracts must notify all stories
- Database migrations affect all dependent stories

**üö´ Merging out of order**:
- Story C depends on Story B ‚Üí B must merge first

**üö´ Stale feature context**:
- Update context after every story completion
- Review dependencies before starting new story

---

**Remember**: Feature Lead owns the feature context. Update after every story milestone.

<!-- Source: local skills/git-worktree-workflow/.apm/instructions/worktree-workflow.instructions.md -->
# Git Worktree Standards

Enable parallel development with isolated working directories per user story.

## Core Concept

**Git worktree creates multiple working directories from one repository**:

```
project/
‚îú‚îÄ‚îÄ .git/                    # Shared repository
‚îú‚îÄ‚îÄ main/                    # Primary worktree (main branch)
‚îî‚îÄ‚îÄ worktrees/
    ‚îú‚îÄ‚îÄ feat-us1/           # Story 1 isolated workspace
    ‚îú‚îÄ‚îÄ feat-us2/           # Story 2 isolated workspace
    ‚îî‚îÄ‚îÄ feat-us3/           # Story 3 isolated workspace
```

**Benefits**:
- ‚úÖ No branch switching
- ‚úÖ No stashing
- ‚úÖ Parallel testing
- ‚úÖ Clear story boundaries

## Worktree Setup

**Create worktree for story**:
```bash
# Create branch and worktree
git worktree add -b feat-us1 worktrees/feat-us1 main

# Agent A works in worktrees/feat-us1/
cd worktrees/feat-us1
# ... implement story ...
```

**List worktrees**:
```bash
git worktree list
# main                     /path/to/project  [main]
# worktrees/feat-us1       /path/to/worktrees/feat-us1  [feat-us1]
# worktrees/feat-us2       /path/to/worktrees/feat-us2  [feat-us2]
```

## Development Workflow

**Story lifecycle**:

1. **Create**: `git worktree add -b feat-us1 worktrees/feat-us1 main`
2. **Develop**: Work in `worktrees/feat-us1/`, commit regularly
3. **Test**: Run tests in worktree: `cd worktrees/feat-us1 && npm test`
4. **Merge**: Return to main, merge branch: `git merge feat-us1 --no-ff`
5. **Cleanup**: Remove worktree: `git worktree remove worktrees/feat-us1`

**Parallel development**:
```bash
# Agent A works on US-001
cd worktrees/feat-us1
npm run dev  # Server on port 3000

# Agent B works on US-002 simultaneously
cd worktrees/feat-us2
npm run dev  # Server on port 3001 (different port!)
```

## Merge Coordination

**Merge order matters**:

```bash
# US-001 complete first (no dependencies)
cd main/
git merge feat-us1 --no-ff
git push origin main

# US-002 depends on US-001, rebase first
cd worktrees/feat-us2
git fetch origin main
git rebase origin/main
# Resolve conflicts if any
cd ../../main/
git merge feat-us2 --no-ff
git push origin main
```

## Worktree Cleanup

**After merge**:
```bash
# Remove worktree
git worktree remove worktrees/feat-us1

# Delete branch (optional)
git branch -d feat-us1
```

**Force remove (if uncommitted changes)**:
```bash
git worktree remove --force worktrees/feat-us1
```

## Anti-Patterns

**üö´ Forgetting to rebase before merge**:
- Always fetch latest main
- Rebase worktree branch on main
- Then merge to main

**üö´ Leaving stale worktrees**:
- Clean up after merge
- Run `git worktree list` to audit

**üö´ Using same port for parallel servers**:
- Each worktree needs unique ports
- Configure in `.env` or command line

---

**Remember**: Worktrees enable true parallel development. One story, one worktree, one agent.

<!-- Source: local skills/claude-framework/.apm/instructions/claude-standards.instructions.md -->
# CLAUDE Framework Coding Standards

Apply these production-ready standards to all code.

## Code Quality (C)

**C-1: Single Responsibility Principle**
- Each function/class does ONE thing
- If a function has "and" in its description, split it

**C-2: DRY (Don't Repeat Yourself)**
- Extract duplicated code into reusable functions
- Create shared utilities for common operations

**C-3: KISS (Keep It Simple)**
- Prefer simple solutions over clever ones
- Avoid premature optimization

**C-4: Function Length**
- Maximum 20 lines per function
- If longer, split into smaller, named functions

**C-5: Composition Over Inheritance**
- Prefer composition and interfaces
- Use inheritance sparingly

## Naming Conventions (N)

**N-1: Descriptive Names**
- Names must explain intent without comments
- `calculateUserTotalPurchases()` not `calc()`

**N-2: Functions as Verbs**
- `fetchUser()`, `validateInput()`, `processPayment()`

**N-3: Variables as Nouns**
- `userAccount`, `totalPrice`, `activeConnection`

**N-4: Boolean Prefixes**
- Use `is`, `has`, `can`, `should`
- `isValid`, `hasPermission`, `canEdit`, `shouldRetry`

**N-5: Constants**
- UPPER_SNAKE_CASE for constants
- `MAX_RETRY_ATTEMPTS`, `API_BASE_URL`

**N-6: No Abbreviations**
- `user` not `usr`, `configuration` not `cfg`

## Error Handling (E)

**E-1: Fail Fast**
- Validate inputs immediately
- Throw errors for invalid states

**E-2: Descriptive Error Messages**
- Include context: what failed, why, what to do
- `"Failed to connect to database 'users_db' at localhost:5432. Check network connectivity."`

**E-3: Error Recovery**
- Provide fallback strategies
- Implement retry logic where appropriate

**E-4: Never Swallow Errors**
- Always log or propagate errors
- No empty catch blocks

**E-5: Use Custom Error Types**
- Create domain-specific error classes
- `ValidationError`, `DatabaseConnectionError`

## Security (S)

**S-1: Input Validation**
- Validate and sanitize all external input
- Use allow-lists, not deny-lists

**S-2: Secrets Management**
- Never hardcode credentials
- Use environment variables or secret managers

**S-3: Principle of Least Privilege**
- Grant minimum necessary permissions
- Apply to users, services, and API keys

**S-4: Secure Dependencies**
- Regularly update dependencies
- Scan for known vulnerabilities

**S-5: Encryption**
- Encrypt sensitive data at rest and in transit
- Use TLS/HTTPS for all network communication

## Testing (T)

**T-1: Test Coverage**
- Minimum 80% code coverage
- 100% coverage for critical paths

**T-2: Test Pyramid**
- Many unit tests
- Some integration tests
- Few end-to-end tests

**T-3: Test Naming**
- `test_<function>_<scenario>_<expected>`
- `test_validateEmail_invalidFormat_throwsError`

**T-4: Arrange-Act-Assert**
- Setup (arrange)
- Execute (act)
- Verify (assert)

**T-5: Isolation**
- Tests must be independent
- No shared mutable state

## Database (D)

**D-1: Parameterized Queries**
- Always use parameterized queries (prevent SQL injection)
- Never concatenate user input into SQL

**D-2: Transactions**
- Use transactions for multi-step operations
- Ensure ACID properties

**D-3: Indexing**
- Index frequently queried columns
- Monitor query performance

**D-4: Connection Pooling**
- Reuse database connections
- Configure appropriate pool size

**D-5: Migration Strategy**
- Version all schema changes
- Test migrations on staging first

## Logging (L)

**L-1: Structured Logging**
- Use JSON format for log parsing
- Include timestamp, level, message, context

**L-2: Log Levels**
- DEBUG: Detailed diagnostic information
- INFO: General informational messages
- WARN: Potentially harmful situations
- ERROR: Error events that might still allow the application to continue
- FATAL: Severe errors that cause termination

**L-3: Log Context**
- Include request ID, user ID, operation
- Enable distributed tracing

**L-4: Performance**
- Log async when possible
- Avoid logging in tight loops

**L-5: Sensitive Data**
- Never log passwords, tokens, or PII
- Redact sensitive information

## Enforcement

When reviewing code, cite specific CLAUDE rules:
- ‚ùå "This function is too complex"
- ‚úÖ "Violates C-4: function exceeds 20 lines. Extract lines 15-25 into `validateUserPermissions()`"

<!-- Source: local skills/tdd-workflow/.apm/instructions/tdd-discipline.instructions.md -->
# TDD Workflow Standards

Apply Test-Driven Development discipline to all code changes.

## Core TDD Cycle: Red ‚Üí Green ‚Üí Refactor

**RED**: Write a failing test
- Test describes desired behavior
- Test fails because feature doesn't exist yet
- Verify test actually fails (confirms test is valid)

**GREEN**: Write minimal code to pass
- Implement simplest solution that makes test pass
- No extra features
- Focus on making the test green

**REFACTOR**: Improve code quality
- Clean up implementation
- Remove duplication
- Improve naming and structure
- **All tests must still pass**

## TDD Mandate

**NEVER write production code without a failing test first**

This applies to:
- ‚úÖ New features
- ‚úÖ Bug fixes
- ‚úÖ Refactoring that changes behavior
- ‚ö†Ô∏è Exception: Pure refactoring (behavior unchanged) with existing test coverage

## File Safety Protocol

**Before modifying existing files**:
1. **Check test coverage**: Does the file have tests?
2. **Run existing tests**: Establish baseline (all green)
3. **Create backup**: Copy file to `filename.backup` if making risky changes
4. **Make changes incrementally**: Small steps with test verification
5. **Remove backup**: Only after all tests pass

**Never**:
- ‚ùå Modify files without understanding test coverage
- ‚ùå Delete or comment out tests to make code pass
- ‚ùå Leave commented-out code in production
- ‚ùå Skip running tests "to save time"

## Test Quality Standards

**Test Naming**: `test_<function>_<scenario>_<expected>`
```python
test_validateEmail_invalidFormat_throwsError
test_calculateTotal_withDiscount_returnsReducedPrice
test_fetchUser_userNotFound_returns404
```

**Test Structure**: Arrange-Act-Assert
```python
def test_addToCart_validItem_increasesCartCount():
    # Arrange: Set up test data
    cart = ShoppingCart()
    item = Product(id=1, name="Widget", price=9.99)
    
    # Act: Execute the operation
    cart.add(item)
    
    # Assert: Verify the outcome
    assert cart.item_count == 1
    assert cart.total == 9.99
```

**Test Independence**:
- Each test runs in isolation
- No shared mutable state
- Use fixtures or setup/teardown for test data
- Tests can run in any order

**Test Coverage**:
- Minimum 80% code coverage
- 100% coverage for critical paths (payment, auth, data loss prevention)
- Test both happy path and edge cases

## Development Workflow

1. **Understand the requirement**
   - Ask clarifying questions
   - Confirm expected behavior
   - Identify edge cases

2. **Write the test (RED)**
   ```python
   def test_processPayment_insufficientFunds_throwsPaymentError():
       account = Account(balance=10.00)
       payment = Payment(amount=50.00)
       
       with pytest.raises(PaymentError, match="Insufficient funds"):
           process_payment(account, payment)
   ```
   - Run test: ‚ùå Fails (function doesn't exist)

3. **Implement minimal code (GREEN)**
   ```python
   def process_payment(account, payment):
       if account.balance < payment.amount:
           raise PaymentError("Insufficient funds")
       account.balance -= payment.amount
   ```
   - Run test: ‚úÖ Passes

4. **Refactor (maintain GREEN)**
   - Improve code quality
   - Extract functions
   - Improve naming
   - Run tests after each refactor: ‚úÖ All pass

5. **Commit**
   - Commit test + implementation together
   - Clear commit message explaining what was added

## Error Handling in Tests

**Test error conditions explicitly**:
```python
def test_connectToDatabase_invalidHost_throwsConnectionError():
    with pytest.raises(ConnectionError, match="Cannot reach host"):
        connect_to_database(host="invalid")

def test_parseJSON_malformedInput_throwsJSONError():
    with pytest.raises(json.JSONDecodeError):
        parse_json("{invalid json")
```

## Integration vs Unit Tests

**Unit Tests** (majority):
- Test one function/method in isolation
- Mock external dependencies (databases, APIs, file system)
- Fast execution (< 100ms each)

**Integration Tests** (fewer):
- Test multiple components together
- Use real dependencies (test database, test API)
- Slower execution (< 5 seconds each)

**Test Pyramid**:
```
     /\
    /  \  E2E (few, slow, expensive)
   /____\
  /      \ Integration (some, moderate)
 /________\
/__________\ Unit (many, fast, cheap)
```

## Code Review Checklist

Before marking code complete:
- ‚úÖ All tests pass
- ‚úÖ No commented-out code
- ‚úÖ Test coverage meets minimum (80%)
- ‚úÖ Tests follow naming convention
- ‚úÖ Tests use Arrange-Act-Assert pattern
- ‚úÖ Edge cases covered
- ‚úÖ Error handling tested
- ‚úÖ No skipped or disabled tests without justification

## When Test-First Doesn't Apply

**Exploratory/Spike Code**:
- Prototyping new library
- Proof of concept
- Research spike

**Process**: Mark as spike, delete after learning, rewrite with TDD

**Legacy Code Without Tests**:
- Add characterization tests first
- Test current behavior (even if buggy)
- Then refactor with safety net

---

**Remember**: "Red ‚Üí Green ‚Üí Refactor" is not optional. It's how we guarantee code quality and prevent regressions.

<!-- Source: local instructions/cross-domain.instructions.md -->
# Cross-Domain Development Principles

These principles apply universally across all agents, skills, and primitives in this repository.

## Package Structure Standards

Every package MUST follow this structure:
```
package-name/
‚îú‚îÄ‚îÄ SKILL.md                 # Package meta-guide (required)
‚îú‚îÄ‚îÄ apm.yml                  # Package manifest (required)
‚îú‚îÄ‚îÄ README.md                # Full documentation (recommended)
‚îî‚îÄ‚îÄ .apm/                    # Primitives directory (required with content)
    ‚îú‚îÄ‚îÄ instructions/        # Guidelines (optional)
    ‚îú‚îÄ‚îÄ prompts/             # Workflows (optional)
    ‚îú‚îÄ‚îÄ agents/              # Personas (optional)
    ‚îî‚îÄ‚îÄ contexts/            # Knowledge (optional)
```

**Critical**: `.apm/` directories must contain at least one primitive file with actual content. Empty `.apm/` directories will cause validation failures.

## Naming Conventions

### File Naming
- **Instructions**: `topic-name.instructions.md` (kebab-case)
- **Prompts**: `action-name.prompt.md` (kebab-case, verb-based)
- **Agents**: `role-name.agent.md` (kebab-case, noun-based)
- **Contexts**: `domain-knowledge.context.md` (kebab-case)

### Package Naming
- Use descriptive, specific names: `spec-driven-development`, `tdd-workflow`
- Avoid generic names: `utils`, `helpers`, `common`
- Use hyphens, not underscores: `git-worktree-workflow` ‚úÖ, `git_worktree_workflow` ‚ùå

## Content Quality Standards

### SKILL.md Files
- Must have YAML frontmatter with `name` and `description`
- Should provide clear overview of what the skill does
- Should list included primitives
- Should explain when to use this skill

### Agent Files
- Must include expertise areas
- Must define tool boundaries (what agent CAN and CANNOT do)
- Should reference relevant instructions and prompts
- Should specify appropriate LLM model if needed

### Instruction Files
- Must use `applyTo` patterns for targeted application
- Should be focused on specific domain (not kitchen-sink)
- Should include rationale for guidelines
- Should provide examples of good vs bad practices

### Prompt Files
- Must include clear step-by-step process
- Should define validation gates for human approval
- Should specify required context and tools
- Should have measurable success criteria

## Version Control

- Use semantic versioning: `MAJOR.MINOR.PATCH`
- Update `apm.yml` version when publishing changes
- Tag releases in git: `v1.0.0`, `v2.1.0`
- Document breaking changes in CHANGELOG.md

## Testing Before Publishing

Before pushing changes to GitHub:
1. Validate locally: Create test project and `apm install` from local path
2. Check structure: Verify `.apm/` has actual content files
3. Test integration: Confirm prompts, agents, instructions work as expected
4. Review dependencies: Ensure all skill dependencies are populated

## Metadata Standards

Every `apm.yml` must include:
```yaml
name: package-name
version: 1.0.0
description: Clear, concise description (1-2 sentences)
author: Your Name
type: skill  # or hybrid, instructions, prompts
dependencies:
  apm: []  # List dependencies
  mcp: []  # List MCP servers if needed
```

## Documentation Requirements

- **SKILL.md**: Package overview and usage guide
- **README.md**: Comprehensive documentation with examples
- **Comments**: All YAML frontmatter fields explained
- **Examples**: Show how to use the skill/agent in practice

## Anti-Patterns to Avoid

‚ùå Empty `.apm/` directories (will fail validation)
‚ùå Missing YAML frontmatter in primitive files
‚ùå Generic, vague descriptions in `apm.yml`
‚ùå Copying examples without customizing for domain
‚ùå Not testing locally before publishing
‚ùå Mixing multiple concerns in single file
‚ùå No clear separation between instructions, prompts, agents

## Principle: Single Responsibility

Each package, each primitive file should do ONE thing well:
- **Instructions**: Set guidelines for a specific domain
- **Prompts**: Execute a specific workflow
- **Agents**: Embody a specific persona/role
- **Skills**: Provide a specific capability

Don't create monolithic packages. Create composable, focused units.

## Files matching `**/*.agent.md`

<!-- Source: local agents/package-manager/.apm/instructions/agent-lifecycle.instructions.md -->
# Custom Agent Lifecycle Management

Follow the official VS Code custom agent specification when creating, validating, and managing `.agent.md` files.

**Official Spec**: https://code.visualstudio.com/docs/copilot/customization/custom-agents

## What Are Custom Agents?

Custom agents enable you to configure the AI to adopt different personas tailored to specific development roles and tasks. Each persona can have its own behavior, available tools, and instructions.

Custom agents consist of:
- **Instructions**: Guidelines defining how the AI should operate
- **Tools**: Specific capabilities available to the agent
- **Handoffs**: Guided workflows transitioning between agents

## Agent File Structure

### Required Elements

**File Extension**: `.agent.md`
**Default Location**: `.github/agents/` (auto-detected by VS Code)
**Alternative Locations**: 
- Workspace: `.github/agents/` (team-shared)
- User Profile: `~/.vscode/profiles/<profile>/agents/` (personal)

### YAML Frontmatter (Header)

**Supported Attributes** (ONLY these are valid):

```yaml
---
# Required
name: string                  # Agent name (defaults to filename)
description: string           # Brief description (chat placeholder text)

# Optional
argument-hint: string         # Hint text for chat input
tools: [string]              # List of tool/tool-set names
model: string                # AI model name (e.g., "Claude Sonnet 4.5", "GPT-4")
infer: boolean               # Enable as subagent (default: true)
target: string               # Environment: "vscode" or "github-copilot"
mcp-servers: [object]        # MCP server configs (github-copilot only)

# Handoffs (workflow transitions)
handoffs:
  - label: string            # Button text
    agent: string            # Target agent ID
    prompt: string           # Pre-filled prompt
    send: boolean            # Auto-submit (default: false)
---
```

### Markdown Body

Contains the agent implementation:
- Detailed instructions and guidelines
- Specific prompts and behaviors
- Reference to other files via Markdown links
- Tool references using `#tool:<tool-name>` syntax

## Tools Configuration

### Built-in Tools
- `search` - Search workspace
- `fetch` - Fetch web content
- `read` - Read files
- `edit` - Edit files
- `execute` - Run commands
- `usages` - Find code usages
- `githubRepo` - GitHub repository operations

### Tool Sets
- Use server name with wildcard for all MCP tools: `servername/*`
- Can mix built-in tools and MCP tools in same list

### Tool Priority Order
1. Tools specified in prompt file (if any)
2. Tools from referenced custom agent in prompt (if any)
3. Default tools for selected agent

## Handoffs (Guided Workflows)

Handoffs enable sequential workflows with suggested next steps.

**Use Cases**:
- Planning ‚Üí Implementation
- Implementation ‚Üí Review
- Write Failing Tests ‚Üí Write Passing Tests

**Configuration**:
```yaml
handoffs:
  - label: Start Implementation
    agent: implementation
    prompt: Now implement the plan outlined above.
    send: false
```

**Behavior**:
- Handoff buttons appear after chat response completes
- Users click to switch agents with context preserved
- If `send: true`, prompt auto-submits
- If `send: false`, prompt pre-fills for review

## Lifecycle Management

### Creating New Agents

**Command**: `Chat: New Custom Agent` or Configure Custom Agents ‚Üí Create new

**Process**:
1. Choose location (workspace or user profile)
2. Enter filename (becomes default name)
3. Fill YAML frontmatter with supported attributes ONLY
4. Add instructions in markdown body
5. Test agent in chat

**Validation Checklist**:
- [ ] YAML frontmatter uses only supported attributes
- [ ] Description is concise (one sentence)
- [ ] Tools list contains valid tool names
- [ ] Model name is full/official (not aliases)
- [ ] Handoffs reference existing agents
- [ ] Body contains clear instructions
- [ ] No unsupported attributes (expertise, boundaries, skills, author, version, color)

### Updating Agents

**Command**: Configure Custom Agents ‚Üí Select agent to modify

**Safe Update Process**:
1. Open existing `.agent.md` file
2. Verify YAML attributes are supported
3. Move unsupported attributes to body
4. Update instructions in markdown
5. Test changes in chat
6. Commit to version control

### Organizing Agents

**Show/Hide in Dropdown**:
- Configure Custom Agents ‚Üí Hover over agent ‚Üí Click eye icon

**Sharing Across Teams**:
- Workspace agents: `.github/agents/` (team-shared)
- Organization agents: Enable via `github.copilot.chat.customAgents.showOrganizationAndEnterpriseAgents`
- User profile agents: Personal use across workspaces

## Migration from Legacy Formats

### Chat Modes ‚Üí Custom Agents

**Old Format**: `.chatmode.md` in `.github/chatmodes/`
**New Format**: `.agent.md` in `.github/agents/`

**VS Code provides Quick Fix** to:
- Rename `.chatmode.md` ‚Üí `.agent.md`
- Move from `.github/chatmodes/` ‚Üí `.github/agents/`

**Manual Migration**:
1. Rename file extension
2. Move to new directory
3. Update YAML frontmatter (remove unsupported attributes)
4. Test functionality

### Unsupported Attributes Migration

**Move these from YAML to markdown body**:

```yaml
# ‚ùå OLD (in YAML frontmatter)
expertise:
  - domain-1
  - domain-2
boundaries:
  what_i_do:
    - task-1
  what_i_dont_do:
    - anti-task-1
author: Name
version: 1.0.0
color: blue
skills:
  - skill-1
```

```markdown
# ‚úÖ NEW (in markdown body)

## Expertise Areas
- Domain 1
- Domain 2

## What I Do
- Task 1

## What I Don't Do
- Anti-task 1

**Author**: Name  
**Version**: 1.0.0
```

## Best Practices

### Agent Design Principles

1. **Single Responsibility**: Each agent should have one clear purpose
2. **Tool Specificity**: Only include tools needed for the agent's role
3. **Clear Boundaries**: Explicitly state what agent does and doesn't do
4. **Workflow Integration**: Use handoffs for multi-step processes
5. **Descriptive Names**: Use role-based names (Planner, Reviewer, Implementer)

### Tool Selection Guidelines

- **Planning agents**: Read-only tools (`search`, `fetch`, `usages`)
- **Implementation agents**: Full editing tools (`edit`, `execute`)
- **Review agents**: Analysis tools (`search`, `usages`, `fetch`)
- **Security agents**: Scanning and analysis tools only

### Handoff Patterns

**Sequential Workflows**:
```
Plan ‚Üí Implement ‚Üí Review ‚Üí Deploy
```

**Iterative Workflows**:
```
Write Tests (fail) ‚Üí Implement (pass) ‚Üí Refactor
```

**Approval Gates**:
- Use `send: false` for human review between steps
- Use `send: true` for automated transitions (use sparingly)

## Common Pitfalls

### ‚ùå Avoid These Mistakes

1. **Using unsupported YAML attributes** ‚Üí Causes validation errors
2. **Generic tool lists** ‚Üí Include all tools defeats purpose of specialization
3. **Missing descriptions** ‚Üí Users won't understand agent purpose
4. **Vague instructions** ‚Üí AI won't know how to behave
5. **No handoffs** ‚Üí Users manually switch agents (friction)
6. **Auto-send on every handoff** ‚Üí Removes human control
7. **Model aliases** ‚Üí Use "Claude Sonnet 4.5", not "sonnet"

### ‚úÖ Success Patterns

1. **Focused tool sets** ‚Üí Only tools needed for role
2. **Clear descriptions** ‚Üí One-sentence purpose statement
3. **Explicit instructions** ‚Üí Tell AI exactly how to operate
4. **Strategic handoffs** ‚Üí Design complete workflows
5. **Manual approval gates** ‚Üí `send: false` for critical transitions
6. **Testing before sharing** ‚Üí Validate agent behavior in chat
7. **Version control** ‚Üí Track agent evolution over time

## Template Library

### Planning Agent
```markdown
---
name: Planner
description: Generate implementation plans for features and refactoring
tools: ['search', 'fetch', 'usages', 'githubRepo']
model: Claude Sonnet 4.5
handoffs:
  - label: Implement Plan
    agent: implementation
    prompt: Implement the plan outlined above.
    send: false
---

# Planning Instructions

You are in planning mode. Generate implementation plans only.

## What You Do
- Research codebase with search and usages tools
- Generate detailed implementation plans
- Identify dependencies and risks
- Break down into actionable steps

## What You Don't Do
- Make code edits
- Execute commands
- Implement features

## Plan Structure
Include these sections:
- Overview
- Requirements
- Implementation Steps
- Testing Strategy
```

### Implementation Agent
```markdown
---
name: Implementation
description: Implement features following TDD and best practices
tools: ['read', 'edit', 'execute', 'search']
model: Claude Sonnet 4.5
handoffs:
  - label: Request Review
    agent: reviewer
    prompt: Review the implementation for quality and security.
    send: false
---

# Implementation Instructions

You implement features with production quality.

## What You Do
- Write tests first (TDD)
- Implement to pass tests
- Follow code standards
- Add documentation

## What You Don't Do
- Skip tests
- Make breaking changes without approval
- Ignore error handling
```

### Review Agent
```markdown
---
name: Reviewer
description: Review code for quality, security, and best practices
tools: ['read', 'search', 'usages']
model: Claude Sonnet 4.5
handoffs:
  - label: Fix Issues
    agent: implementation
    prompt: Address the review feedback above.
    send: false
---

# Review Instructions

You review code for production readiness.

## Review Checklist
- [ ] Code quality and maintainability
- [ ] Security vulnerabilities
- [ ] Test coverage
- [ ] Documentation
- [ ] Performance considerations

## What You Do
- Identify issues with specific line numbers
- Suggest improvements with examples
- Assess production readiness
- Flag blocking issues

## What You Don't Do
- Implement fixes (delegate to implementation agent)
- Approve without thorough review
```

## Validation Commands

When creating or updating agents, validate with these checks:

```bash
# Check for unsupported attributes
grep -E "^(expertise|boundaries|author|version|color|skills):" .github/agents/*.agent.md

# Verify file structure
ls -la .github/agents/

# Test in VS Code
# 1. Open Command Palette (Cmd+Shift+P)
# 2. Run: Chat: New Custom Agent
# 3. Test agent in chat view
```

## References

- **Official Docs**: https://code.visualstudio.com/docs/copilot/customization/custom-agents
- **Tool Documentation**: https://code.visualstudio.com/docs/copilot/chat/chat-tools
- **Prompt Files**: https://code.visualstudio.com/docs/copilot/customization/prompt-files
- **Custom Instructions**: https://code.visualstudio.com/docs/copilot/customization/custom-instructions

## Files matching `**/SKILL.md`

<!-- Source: local agents/package-manager/.apm/instructions/agent-skills-spec.instructions.md -->
# Agent Skills Specification Compliance

Follow the official Agent Skills format specification when creating or modifying SKILL.md files.

**Official Spec**: https://agentskills.io/specification

## SKILL.md Structure

Every skill must have a `SKILL.md` file at the root with:
1. **YAML frontmatter** (required)
2. **Markdown body** (instructions)

## YAML Frontmatter Requirements

### Required Fields

```yaml
---
name: skill-name
description: A description of what this skill does and when to use it.
---
```

**name field rules**:
- Must be 1-64 characters
- Lowercase alphanumeric and hyphens only (`a-z`, `0-9`, `-`)
- Cannot start or end with hyphen
- No consecutive hyphens (`--`)
- Must match parent directory name

**description field rules**:
- Must be 1-1024 characters
- Should describe BOTH:
  - What the skill does
  - When to use it
- Include specific keywords for discoverability

### Optional Fields

```yaml
---
name: skill-name
description: Complete description with use cases
license: Apache-2.0
compatibility: Requires git, docker, and internet access
metadata:
  author: example-org
  version: "1.0"
allowed-tools: Bash(git:*) Bash(jq:*) Read
---
```

**license** (optional):
- Short license name or reference to bundled LICENSE file
- Example: "Apache-2.0" or "Proprietary. See LICENSE.txt"

**compatibility** (optional, 1-500 characters):
- Only include if skill has specific environment requirements
- Indicate intended product, system packages, network access
- Example: "Designed for Claude Code (or similar products)"
- Example: "Requires git, docker, jq, and access to the internet"

**metadata** (optional):
- Map of string keys to string values
- Store additional properties not in spec
- Use unique key names to avoid conflicts
- Example: author, version, tags, url

**allowed-tools** (optional, experimental):
- Space-delimited list of pre-approved tools
- Example: "Bash(git:*) Bash(jq:*) Read"

## Markdown Body Guidelines

The body contains skill instructions. No format restrictions.

**Recommended sections**:
- Step-by-step instructions
- Examples of inputs and outputs
- Common edge cases and error handling
- When to use this skill
- When NOT to use this skill

**Progressive disclosure**:
- Keep main SKILL.md under 500 lines
- Move detailed reference to `references/` directory
- Keep instructions focused and scannable

## Optional Directory Structure

### scripts/
Contains executable code agents can run.

**Best practices**:
- Self-contained or clearly document dependencies
- Include helpful error messages
- Handle edge cases gracefully
- Support common languages: Python, Bash, JavaScript

**Reference scripts in SKILL.md**:
```markdown
Run the validation script:
[scripts/validate.py](scripts/validate.py)
```

### references/
Contains additional documentation loaded on demand.

**Recommended files**:
- `REFERENCE.md` - Detailed technical reference
- `FORMS.md` - Form templates or structured data
- Domain-specific files: `finance.md`, `legal.md`

**Keep files focused** - Agents load on demand, smaller is better.

**Reference in SKILL.md**:
```markdown
See [the reference guide](references/REFERENCE.md) for details.
```

### assets/
Contains static resources.

**Common assets**:
- Templates (document templates, configuration)
- Images (diagrams, examples)
- Data files (lookup tables, schemas)

## Progressive Disclosure Pattern

Structure skills for efficient context use:

1. **Metadata** (~100 tokens): name + description loaded at startup for ALL skills
2. **Instructions** (< 5000 tokens): SKILL.md body loaded when skill activated
3. **Resources** (as needed): scripts/, references/, assets/ loaded only when required

**Optimization**:
- Keep SKILL.md under 500 lines
- Move detailed docs to `references/`
- Keep file references one level deep

## File References

Use relative paths from skill root:

```markdown
See [reference guide](references/REFERENCE.md) for details.

Run extraction:
[scripts/extract.py](scripts/extract.py)

Use template:
[assets/template.json](assets/template.json)
```

**Avoid deep nesting** - Keep references one level deep from SKILL.md.

## Validation

### Using skills-ref Library

```bash
# Install
pip install skills-ref

# Validate skill
skills-ref validate ./my-skill

# Checks:
# - SKILL.md frontmatter validity
# - name field compliance
# - description length
# - naming conventions
```

### Manual Validation Checklist

**Frontmatter**:
- [ ] `name` field present (1-64 chars, lowercase, hyphens only)
- [ ] `description` field present (1-1024 chars, describes what + when)
- [ ] name matches directory name
- [ ] No unsupported fields in frontmatter

**Structure**:
- [ ] SKILL.md at root (not in subdirectory)
- [ ] Optional directories used correctly (scripts/, references/, assets/)
- [ ] File references use relative paths
- [ ] No deeply nested reference chains

**Content Quality**:
- [ ] Description includes specific keywords
- [ ] Instructions are clear and actionable
- [ ] SKILL.md under 500 lines (move extras to references/)
- [ ] Scripts have error handling
- [ ] Examples provided where helpful

## Common Pitfalls

### ‚ùå Name Field Errors

```yaml
# WRONG - uppercase
name: PDF-Processing

# WRONG - starts with hyphen
name: -pdf-tools

# WRONG - consecutive hyphens
name: pdf--processor

# WRONG - underscores
name: pdf_processing

# WRONG - doesn't match directory
# Directory: pdf-tools/
name: pdf-processor

# ‚úÖ CORRECT
name: pdf-processing
```

### ‚ùå Description Too Vague

```yaml
# WRONG - no context
description: Helps with PDFs

# ‚úÖ CORRECT - describes what and when
description: Extracts text and tables from PDF files, fills forms, and merges documents. Use when working with PDF documents or when user mentions PDFs, forms, or document extraction.
```

### ‚ùå SKILL.md in Wrong Location

```
# WRONG
skill-name/
‚îî‚îÄ‚îÄ .apm/
    ‚îî‚îÄ‚îÄ skills/
        ‚îî‚îÄ‚îÄ SKILL.md  ‚ùå

# ‚úÖ CORRECT
skill-name/
‚îî‚îÄ‚îÄ SKILL.md  ‚úÖ
```

### ‚ùå Over-Complex Structure

```
# WRONG - deeply nested
references/
  detailed/
    specific/
      very-specific.md  ‚ùå

# ‚úÖ CORRECT - one level deep
references/
  detailed-reference.md  ‚úÖ
```

## Integration with APM

APM packages can contain skills. When creating skills within APM:

**Structure**:
```
skills/my-skill/
‚îú‚îÄ‚îÄ SKILL.md              # Agent Skills spec
‚îú‚îÄ‚îÄ apm.yml               # APM manifest
‚îî‚îÄ‚îÄ .apm/                 # APM primitives
    ‚îú‚îÄ‚îÄ instructions/
    ‚îú‚îÄ‚îÄ prompts/
    ‚îî‚îÄ‚îÄ agents/
```

**Key difference**:
- **SKILL.md** = Agent Skills format (name, description in frontmatter)
- **apm.yml** = APM manifest (dependencies, version)
- Both can coexist in same package

## Template

```yaml
---
name: skill-name
description: Brief description of what this skill does and when to use it. Include specific keywords that help agents identify relevant tasks.
license: Apache-2.0
metadata:
  author: your-org
  version: "1.0"
---

# Skill Name

[Brief overview paragraph]

## When to Use This Skill

- Situation 1
- Situation 2
- When user mentions [keywords]

## How It Works

[Step-by-step instructions]

### Step 1: [Action]
[Details]

### Step 2: [Action]
[Details]

## Examples

### Example 1: [Scenario]
[Input]
[Process]
[Output]

## Common Issues

- Issue: [Description]
  - Solution: [Fix]

## Scripts

This skill includes helper scripts:
- [scripts/helper.py](scripts/helper.py) - [Purpose]

## Additional Resources

- [references/REFERENCE.md](references/REFERENCE.md) - Detailed reference
```

## Validation Commands

```bash
# Validate with skills-ref
skills-ref validate ./my-skill

# Check name compliance
echo "skill-name" | grep -E '^[a-z0-9][a-z0-9-]{0,62}[a-z0-9]$'

# Check directory name matches SKILL.md name
skill_name=$(grep "^name:" SKILL.md | awk '{print $2}')
dir_name=$(basename "$PWD")
[ "$skill_name" = "$dir_name" ] && echo "‚úÖ Match" || echo "‚ùå Mismatch"
```

## References

- **Official Spec**: https://agentskills.io/specification
- **skills-ref Library**: https://github.com/agentskills/agentskills/tree/main/skills-ref
- **Example Skills**: https://github.com/agentskills/agentskills

## Files matching `src/**,api/**,frontend/**,backend/**`

<!-- Source: local skills/fullstack-expertise/.apm/instructions/fullstack-standards.instructions.md -->
# Full-Stack Development Standards

Apply production-ready practices across the entire application stack.

## Backend Development

### API Design
- Use RESTful conventions: GET (read), POST (create), PUT/PATCH (update), DELETE (remove)
- Resource-based URLs: `/api/users/{id}`, not `/api/getUserById`
- Proper HTTP status codes: 200 (OK), 201 (Created), 400 (Bad Request), 401 (Unauthorized), 404 (Not Found), 500 (Server Error)
- Versioning in URL: `/api/v1/users` or header: `Accept: application/vnd.api+json; version=1`

### Error Handling
- Return consistent error format:
  ```json
  {
    "error": {
      "code": "VALIDATION_ERROR",
      "message": "Email format invalid",
      "field": "email"
    }
  }
  ```
- Use appropriate status codes
- Log errors server-side with request context

### Security
- Input validation on all API endpoints
- Authentication (JWT, OAuth2)
- Authorization (RBAC, permissions)
- Rate limiting
- CORS configuration
- Secure password storage (bcrypt, Argon2)

## Frontend Development

### Component Architecture
- Single Responsibility: One component, one purpose
- Props for configuration, state for interaction
- Lift state up to common ancestor
- Use composition over prop drilling

### State Management
- Local state for UI-only (open/closed, form input)
- Global state for shared data (user, app settings)
- Server state separate from client state
- Optimize re-renders

### Accessibility (a11y)
- Semantic HTML: `<button>`, `<nav>`, `<main>`, `<article>`
- ARIA labels for screen readers
- Keyboard navigation support
- Color contrast ratios (WCAG AA minimum)
- Focus management

### Performance
- Code splitting and lazy loading
- Image optimization
- Minimize bundle size
- Virtual scrolling for long lists
- Memoization for expensive calculations

## Database

### Schema Design
- Normalized structure (avoid redundancy)
- Appropriate data types
- Constraints: NOT NULL, UNIQUE, CHECK
- Foreign keys for referential integrity

### Indexing
- Index frequently queried columns
- Composite indexes for multi-column queries
- Monitor slow queries

### Transactions
- ACID properties for critical operations
- Isolation levels appropriate to use case
- Rollback on errors

### Performance
- Connection pooling
- Query optimization
- Avoid N+1 queries
- Use pagination for large datasets

## DevOps & Deployment

### Environment Management
- Development, Staging, Production environments
- Environment variables for configuration
- Never commit secrets to version control

### CI/CD
- Automated testing on every commit
- Linting and type checking in pipeline
- Automated deployment to staging
- Manual approval for production

### Monitoring
- Application logs (structured JSON)
- Error tracking (Sentry, Rollbar)
- Performance monitoring (APM tools)
- Health check endpoints

### Containerization
- Dockerfile for consistent environments
- Multi-stage builds for smaller images
- Docker Compose for local development

---

**Remember**: Full-stack means owning quality at every layer.

---
*This file was generated by APM CLI. Do not edit manually.*
*To regenerate: `specify apm compile`*
